#include "errors.fc";
#include "opcodes.fc";
#include "stdlib.fc";
#include "utils.fc";

const int event_id::lock_ton = 101;
const int event_id::burn_jetton = 102;

;; load_data returns data from c4 cell.
(slice, cell, cell) load_data() inline_ref {
    slice data = get_data().begin_parse();

    return (
        data~load_msg_addr(),   ;; admin address
        data~load_dict(),       ;; oracles
        data~load_ref()         ;; jetton minter code
    );
}

;; save_data saves data to c4 cell.
;; admin_address:MsgAddress - admin address.
;; oracles:^Cell - dict of oracles.
() save_data(slice admin_address, cell oracles) impure inline_ref {
    cell data = begin_cell()
                    .store_slice(admin_address)
                    .store_dict(oracles)
                .end_cell();

    set_data(data);
}

;; get_oracles returns a dict of oracles stored in c4 cell.
;; key: uint256 (public key), value: (key: uint256 (chain id), value: uint256 (public key for chain))
cell get_oracles() inline {
    (_, cell oracles, _) = load_data();
    return oracles;
}

;; get_admin_address returns admin address stored in c4 cell.
slice get_admin_address() inline {
    (slice admin_address, _, _) = load_data();
    return admin_address;
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    var cs = in_msg_full.begin_parse();  
    var flags = cs~load_uint(4); ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool

    if (flags & 1) {
        return (); ;; ignore all bounced messages
    }

    slice sender_address = cs~load_msg_addr();
    (_, int sender_address_hash) = parse_std_addr(sender_address);

    throw_if(error::empty_msg_body, in_msg_body.slice_empty?());

    (int op, int query_id) = in_msg_body~load_body_header();

    if (op == op::lock_ton) {
        int destination_address = in_msg_body~load_uint(160);
        int destination_chain_id = in_msg_body~load_uint(32);

        emit_log(
            event_id::lock_ton,
            begin_cell()
                .store_uint(destination_address, 160)
                .store_uint(destination_chain_id, 32)
                .store_uint(sender_address_hash, 256)
                .store_uint(msg_value, 64)
            .end_cell(),
            null()
        );
    } elseif (op == op::unlock_ton) {
        cell oracles = get_oracles();
        (_, int is_oracle) = oracles.udict_get?(256, sender_address_hash);

        throw_if(error::not_an_oracle, ~ is_oracle);

        slice to_address = in_msg_body~load_msg_addr();
        int unlock_value = in_msg_body~load_uint(64);

        cell transfer_msg = begin_cell()
                                .store_uint(0x18, 6)
                                .store_slice(to_address)
                                .store_coins(unlock_value)
                                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                            .end_cell();

        ;; send_mode - 0 to pay fee with the unlocked coins.
        ;; this will reduce the amount of fees paid by the oracle.
        send_raw_message(transfer_msg, 0);
    } elseif (op == op::burn_notification()) {
        int burn_value = in_msg_body~load_coins();
        int destination_address = in_msg_body~load_uint(160);
        int destination_chain_id = in_msg_body~load_uint(32);
        
        emit_log(
            event_id::burn_jetton,
            begin_cell()
                .store_uint(destination_address, 160)
                .store_uint(destination_chain_id, 32)
                .store_uint(burn_value, 64)
            .end_cell(),
            null()
        );
    } elseif (op == op::add_jetton) {
        (_, int admin_address_hash) = parse_std_addr(get_admin_address());
        throw_if(error::not_admin, sender_address_hash != admin_address_hash);

        int chain_id = in_msg_body~load_uint(32);

        ;; TODO: check if chain_id is already added

        cell jetton_content = in_msg_body~load_ref();
        slice jetton_address = deploy_jetton(jetton_content);

        ;; TODO: store jetton info
    } else {
        throw(error::unknown_operation);
    }
}

slice deploy_jetton(cell content) impure {
    (_, _, cell jetton_minter_code) = load_data();

    cell jetton_minter_data = begin_cell()
                                .store_coins(0)                 ;; total supply 
                                .store_ref(content)             ;; jetton data
                                .store_ref(jetton_minter_code)  ;; minter code 
                            .end_cell();

    cell jetton_state_init = begin_cell()
                                .store_uint(0, 2)
                                .store_dict(jetton_minter_code)
                                .store_dict(jetton_minter_data)
                                .store_uint(0, 1)
                            .end_cell();

    slice jetton_address = calculate_address_by_state_init(jetton_state_init);

    cell msg = begin_cell()
                .store_uint(0x18, 6)
                .store_slice(jetton_address)
                .store_coins(0)
                .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(jetton_state_init)
                .store_ref(content)
            .end_cell();

    ;; send mode - 1 to pay transfer fees separately, revert on errors
    send_raw_message(msg, 1);

    return jetton_address;
}